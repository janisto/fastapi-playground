---
description: AI agent guidelines for this FastAPI/Python repository. Covers coding conventions, project structure, workflow principles, and tech stack (Python 3.14+, FastAPI, Pydantic v2, Firebase).
---

# Copilot Instructions

These guidelines define how AI agents and contributors should work in this FastAPI/Python repository. Use GitHub Issues/PRs for tracking, GitHub Actions for CI (if configured), and local tooling via uv and just.

> **Ruff Linter Coverage**: Code quality is enforced via Ruff with comprehensive rules in `pyproject.toml`:
> - **ANN**: Type annotations required (functions, args, returns)
> - **B**: Bugbear patterns (mutable defaults, unused loop vars)
> - **C4/SIM**: Simplification (comprehensions, boolean logic)
> - **FAST**: FastAPI-specific (redundant response_model, unused path params)
> - **G/LOG**: Logging format (no f-strings in log calls, use logger.exception)
> - **I**: Import sorting (automatic via Ruff formatter)
> - **N**: PEP8 naming conventions (classes, functions, variables)
> - **PT**: Pytest style (fixture syntax, assertion patterns)
> - **RET**: Return statement patterns (no implicit returns, no unnecessary else)
> - **S**: Security (bandit rules, no hardcoded secrets)
> - **T20**: No print statements (use logging)
> - **TRY**: Exception handling patterns
> - **UP**: Modern Python syntax (pyupgrade for 3.14+)
>
> Run `just lint` to check and auto-fix. This document focuses only on project-specific conventions.

---

## Comment & Output Restraint

Keep output and code/doc comments minimal and purposeful.

- Do NOT add progress logs, narrative explanations, or meta commentary (e.g., "updating file", "starting patch", "work in progress") to source code, docs, tests, or commit diffs.
- No autogenerated banners or markers like "Generated by".
- Never use emojis in code, comments, documentation, or commit messages.
- Inline comments only when they clarify non-obvious intent, business rules, performance trade-offs, or security rationale. Omit comments that restate the code.
- Remove obsolete/stale comments when changing related code.
- Avoid speculative TODOs; only leave a TODO if it is immediately actionable, clearly scoped, and required. Prefer creating a tracked issue instead.
- Do not insert review-style remarks ("nit:", "consider:") inside committed files.
- Keep examples free of progress chatter—only the example code and essential annotations.
- **Docstrings must be multi-line**: Always use multi-line format for all docstrings, even single-sentence ones. The opening `"""` should be on its own line:
  ```python
  # Correct
  def example() -> None:
      """
      Brief description of the function.
      """

  # Wrong
  def example() -> None:
      """Brief description of the function."""
  ```

Violations should be removed before a PR is marked ready. Default to silence unless a comment adds enduring value.

---

## Workflow Principles

- Correctness first: Prioritize correctness, then readability/maintainability, then performance.
- Reflect before acting: After tool results, briefly summarize insights, list next options, and pick the best one.
- Parallelize independent steps: Run unrelated reads/checks in parallel to maximize efficiency.
- No leftovers: Remove temporary files/scripts/debug outputs before finishing. Keep `git status` clean aside from intended changes.
- No legacy aliases: Never add backwards-compatibility shims or deprecated aliases. Refactor all usages to the new convention instead.
- Ask when unsure: If requirements are ambiguous, seek clarification rather than guessing.
- Well-supported dependencies: Prefer widely used, well-documented libraries with active maintenance. Ask permission before adding new dependencies.
- Security first: Never exfiltrate secrets; avoid network calls unless explicitly required. Do not log PII or secrets.
- After editing code: Run `just lint` and `just typing` to ensure lint/type compliance.

---

## Tech & Tooling

- Language/runtime: Python 3.14+
- Frameworks/libs: FastAPI, Pydantic v2, Uvicorn, Firebase Admin SDK, Google Cloud (Firestore/Logging/Secret Manager)
- Package/devenv: uv (+ virtualenv in `.venv`), Justfile for tasks
- Lint/format: Ruff (line-length 120; comprehensive rules in pyproject.toml)
- Type checking: ty
- Testing: pytest, pytest-asyncio, coverage

Use uv consistently (do not mix with pip/poetry within this repo). Prefer `just` shortcuts where available.

---

## Coding Guidelines

### REST API Guidelines

This project follows modern REST API best practices:

#### Response Conventions

- Return resources directly without wrapper envelopes
- POST endpoints return 201 Created with `Location` header
- DELETE endpoints return 204 No Content
- All timestamps use ISO 8601 format with UTC timezone and explicit milliseconds (e.g., `2025-01-15T10:30:00.000Z`)

```python
# Correct - return resource directly
@router.get("")
async def get_profile(current_user: CurrentUser) -> Profile:
    return await service.get_profile(current_user.uid)

# Correct - POST with 201 and Location header
@router.post("", status_code=status.HTTP_201_CREATED)
async def create_profile(..., response: Response) -> Profile:
    profile = await service.create_profile(...)
    response.headers["Location"] = "/profile"
    return profile

# Correct - DELETE with 204 No Content
@router.delete("", status_code=status.HTTP_204_NO_CONTENT)
async def delete_profile(...) -> None:
    await service.delete_profile(...)
    return None
```

#### Error Handling with fastapi-problem

Errors use RFC 9457 Problem Details format via `fastapi-problem`:

```json
{
  "type": "about:blank",
  "title": "Not Found",
  "status": 404,
  "detail": "Profile not found"
}
```

Define domain exceptions using fastapi-problem base classes:

```python
# app/exceptions/profile.py
from fastapi_problem.error import ConflictProblem, NotFoundProblem

class ProfileNotFoundError(NotFoundProblem):
    """Raised when a profile cannot be found."""
    title = "Profile not found"

class ProfileAlreadyExistsError(ConflictProblem):
    """Raised when attempting to create a duplicate profile."""
    title = "Profile already exists"
```

Register the exception handler in `main.py`:

```python
from fastapi_problem.handler import add_exception_handler
from app.core.exception_handler import eh

add_exception_handler(app, eh)
```

Validation errors (422) use a structured format with `errors` array:

```json
{
  "type": "about:blank",
  "title": "Validation Error",
  "status": 422,
  "detail": "Request validation failed",
  "errors": [
    {"location": "body.email", "message": "value is not a valid email address", "value": "invalid"}
  ]
}
```

#### Request Tracking (X-Request-ID)

All requests include an `X-Request-ID` header:
- Echoes client-provided ID or generates UUID v4
- Appears in all responses including errors
- Implemented via `RequestContextLogMiddleware` and exception handler hooks

#### Content Negotiation (JSON/CBOR)

The API supports JSON (default) and CBOR (RFC 8949):

```python
from app.core.cbor import CBORRoute

router = APIRouter(
    prefix="/items",
    route_class=CBORRoute,  # Enables automatic CBOR negotiation
)
```

- `Accept: application/cbor` returns CBOR-encoded response
- `Content-Type: application/cbor` accepts CBOR-encoded request body
- Errors respect Accept header (`application/problem+cbor` when appropriate)

#### Pagination Implementation

Use cursor-based pagination with RFC 8288 Link headers. The `paginate()` helper validates cursor types and raises `InvalidCursorError` on type mismatch, returning 400 Bad Request (per HTTP semantics, an invalid cursor is a malformed request parameter, not a schema validation error):

```python
from app.pagination import paginate

@router.get("")
async def list_items(
    request: Request,
    response: Response,
    cursor: CursorParam = None,
    limit: LimitParam = 10,
) -> ItemList:
    items = get_all_items()  # Your data source
    
    result = paginate(
        items=items,
        cursor=cursor,
        limit=limit,
        cursor_type="item",  # Cursor type must match or 400 Bad Request is returned
        get_id=lambda x: x.id,
        base_url=str(request.url.path),
        query_params={"limit": str(limit)},
    )
    
    if result.link_header:
        response.headers["Link"] = result.link_header
    
    return ItemList(items=result.items, total=result.total)
```

For manual cursor handling (simpler cases):

```python
from app.pagination import Cursor, CursorParam, LimitParam, build_link_header, decode_cursor

@router.get("")
async def list_items(
    request: Request,
    response: Response,
    cursor: CursorParam = None,
    limit: LimitParam = 10,
) -> ItemList:
    # Decode cursor
    start_idx = 0
    if cursor:
        decoded = decode_cursor(cursor)
        if decoded.type == "idx":
            start_idx = int(decoded.value)

    # Build next/prev cursors
    next_cursor = Cursor(type="idx", value=str(end_idx)).encode()

    # Add Link header
    link = build_link_header(
        base_url=str(request.url.path),
        query_params={"limit": str(limit)},
        next_cursor=next_cursor,
        prev_cursor=prev_cursor,
    )
    if link:
        response.headers["Link"] = link
```

#### JSON Schema References ($schema field)

Responses include a `$schema` field pointing to a JSON Schema document for self-description:

```python
class ItemList(BaseModel):
    model_config = ConfigDict(populate_by_name=True, serialize_by_alias=True)

    schema_url: str | None = Field(
        default=None,
        alias="$schema",
        description="JSON Schema URL for this response",
        examples=["/schemas/ItemsData.json"],  # Use relative path in examples
    )
    items: list[Item] = Field(...)
    total: int = Field(...)
```

**Important**: Per JSON Schema spec, the `$schema` value MUST be an absolute URI with a scheme. Use `request.base_url` to build the full URL at runtime:

```python
@router.get("")
async def list_items(request: Request, response: Response) -> ItemList:
    # Add describedBy Link header
    response.headers["Link"] = '</schemas/ItemsData.json>; rel="describedBy"'
    
    return ItemList(
        schema_url=str(request.base_url) + "schemas/ItemsData.json",  # Absolute URL
        items=page_items,
        total=len(filtered_items),
    )
```

- Field `examples` can use relative paths (documentation only)
- Runtime `$schema` value must be absolute (e.g., `http://api.example.com/schemas/ItemsData.json`)
- Also add `Link` header with `rel="describedBy"` for discoverability

---

- FastAPI style
  - Use `async def` for I/O-bound endpoints and services.
  - Validate inputs/outputs with Pydantic models; set `response_model` and explicit status codes.
  - Keep separate request/response models (no leaking internal fields).
  - Raise `HTTPException` with clear messages; add contextual logging on failures.
  - Keep routers thin; put business logic in `services/` and shared logic in `core/`.
  - **Use lifespan context manager** for app startup/shutdown. Initialize Firebase and logging on startup; close async clients on shutdown:
    ```python
    from contextlib import asynccontextmanager
    from collections.abc import AsyncGenerator

    @asynccontextmanager
    async def lifespan(app: FastAPI) -> AsyncGenerator[None]:
        """
        Application lifespan manager.
        """
        # Startup
        setup_logging()
        initialize_firebase()
        yield
        # Shutdown
        await close_async_firestore_client()

    app = FastAPI(lifespan=lifespan, ...)
    ```
  - **Middleware order matters**: Last added = outermost (first to run on request). Order in `main.py`:
    1. CORS (innermost) - handles preflight
    2. BodySizeLimitMiddleware - reject oversized requests early
    3. SecurityHeadersMiddleware - add security headers to responses
    4. RequestContextLogMiddleware (outermost) - capture full request lifecycle
  - **Always add meaningful docstrings to endpoint functions.** Describe what the endpoint does, key behaviors, and notable error conditions. The docstring complements the decorator's `summary`/`description` by documenting implementation details for developers:
    ```python
    async def create_profile(...) -> ProfileResponse:
        """
        Create a new profile for the authenticated user.

        Stores the profile data in Firestore under the user's UID.
        Returns 409 Conflict if a profile already exists.
        """
    ```
  - **Prefer `Literal` types over regex patterns** for query parameters with fixed allowed values. `Literal` provides better OpenAPI documentation (enum values in Swagger UI), type checker support, and clearer validation errors:
    ```python
    # Preferred - use Literal for fixed value sets
    from typing import Literal
    sort_order: Annotated[Literal["asc", "desc"] | None, Query(description="Sort order")] = None

    # Avoid - regex pattern for fixed value sets
    sort_order: Annotated[str | None, Query(pattern="^(asc|desc)$")] = None
    ```
  - **Use dependency type aliases** for cleaner router signatures. Define in `app/dependencies.py`:
    ```python
    from typing import Annotated
    from fastapi import Depends
    from app.auth.firebase import FirebaseUser, verify_firebase_token
    from app.services.profile import ProfileService

    # Auth dependency - use in router parameters
    CurrentUser = Annotated[FirebaseUser, Depends(verify_firebase_token)]

    # Service dependency - inject via DI
    def get_profile_service() -> ProfileService:
        """
        Dependency provider for ProfileService.
        """
        return ProfileService()

    ProfileServiceDep = Annotated[ProfileService, Depends(get_profile_service)]
    ```
    Usage in routers:
    ```python
    from app.dependencies import CurrentUser, ProfileServiceDep

    async def create_profile(
        profile_data: ProfileCreate,
        current_user: CurrentUser,
        service: ProfileServiceDep,
    ) -> ProfileResponse:
    ```

- Pydantic schemas (`app/models/`)
  - Always use `model_config = ConfigDict(...)` at class level for type safety and IDE support. Never use the deprecated `class Config:` inner class or plain `dict`.
  - Use `extra="forbid"` for request models to reject unknown fields.
  - Response models typically omit `extra="forbid"` unless strict output is required.
  - **Response models should NOT inherit from request base models** that have `extra="forbid"`. Define full entity models separately to avoid rejecting extra fields in responses:
    ```python
    # Request models with extra="forbid"
    class ProfileBase(BaseModel):
        firstname: str = Field(...)
        # ... other fields
        model_config = ConfigDict(extra="forbid")

    class ProfileCreate(ProfileBase):
        pass

    # Response model - does NOT inherit from ProfileBase
    class Profile(BaseModel):
        """
        Complete profile model with metadata.

        Note: Does not inherit from ProfileBase to avoid extra="forbid" which is
        inappropriate for response models.
        """
        id: str = Field(...)
        firstname: str = Field(...)
        # ... all fields defined explicitly
        created_at: UtcDatetime = Field(...)
        updated_at: UtcDatetime = Field(...)
    ```
  - **Use `serialize_by_alias=True`** for models with field aliases (e.g., `alias="$schema"`). This ensures `model_dump()` uses aliases by default, matching FastAPI's `response_model_by_alias=True` behavior. This setting was introduced in Pydantic v2.11 and will default to `True` in v3:
    ```python
    class HealthResponse(BaseModel):
        model_config = ConfigDict(populate_by_name=True, serialize_by_alias=True)

        schema_url: str | None = Field(default=None, alias="$schema", ...)
        message: str = Field(...)
    ```
  - Use `from_attributes=True` for models that need to be constructed from ORM-like objects or dataclasses.
  - Use Pydantic v2 `.model_dump()` for serialization instead of deprecated `.dict()`. Use `exclude_unset=True` for partial updates.
  - Add docstrings to models describing their purpose.
  - Use `Field(...)` with `description` for OpenAPI documentation.
  - **Firestore collection constants**: Define collection names as module-level constants in the relevant model file (typically the response model file within the domain subdirectory):
    ```python
    # app/models/profile/responses.py
    PROFILE_COLLECTION = "profiles"
    ```
    Re-export from `__init__.py` and import in services to ensure consistency:
    ```python
    from app.models.profile import PROFILE_COLLECTION
    ```
  - **Field-level examples**: Scalar fields MUST have `Field(examples=[...])` for OpenAPI documentation. Array/list fields of nested models should **omit** examples since the nested schema provides documentation automatically:
    ```python
    from pydantic import BaseModel, EmailStr, Field

    class ProfileCreate(BaseModel):
        """
        Request schema for creating a profile.
        """

        firstname: str = Field(..., min_length=1, max_length=100, description="First name", examples=["John"])
        lastname: str = Field(..., min_length=1, max_length=100, description="Last name", examples=["Doe"])
        email: EmailStr = Field(..., description="Email address", examples=["user@example.com"])
        phone_number: str = Field(..., description="Phone in E.164 format", examples=["+358401234567"])
        marketing: bool = Field(default=False, description="Marketing opt-in", examples=[False])
    ```
  - **Do not use `json_schema_extra`**: Model-level `json_schema_extra={"examples": [...]}` is deprecated. Always use field-level `examples=[...]` instead.
  - **Example format by field type**:
    | Field Type | Example Format |
    |------------|----------------|
    | `str` | `examples=["value"]` |
    | `int` | `examples=[123]` |
    | `float` | `examples=[19.99]` |
    | `bool` | `examples=[True]` |
    | `UtcDatetime` | `examples=["2025-01-15T10:30:00.000Z"]` (use .000Z format for consistency) |
    | `list[str]` | `examples=[["item1", "item2"]]` (array of primitives) |
    | `list[Model]` | **Omit examples** (nested schema auto-documents via `$ref`) |
    | `EmailStr` | `examples=["user@example.com"]` |
    | `T \| None` | Provide example for `T`; omit `None` |

- Schema naming conventions
  - **Never reuse a response model as a request body.** Keep request and response models strictly separate.
  - Use consistent naming to distinguish request vs response models:
    | Purpose | Naming Pattern | Example |
    |---------|----------------|---------|
    | Base class (internal) | `{Resource}Base` | `ProfileBase` |
    | Create request | `{Resource}Create` | `ProfileCreate` |
    | Update request | `{Resource}Update` | `ProfileUpdate` |
    | Standard response | `{Resource}Response` | `ProfileResponse` |
    | Full entity (internal) | `{Resource}` | `Profile` |
  - Avoid ambiguous names; always indicate request or response purpose.

- Shared type aliases (`app/models/types.py`)
  - Use predefined type aliases for common constrained strings instead of inline constraints. Create `app/models/types.py` for reusable types:
    ```python
    # app/models/types.py
    from datetime import datetime
    from typing import Annotated
    from pydantic import AfterValidator, EmailStr, PlainSerializer, StringConstraints

    def _serialize_datetime_ms(value: datetime) -> str:
        """Serialize datetime with explicit milliseconds (.000Z format)."""
        return value.strftime("%Y-%m-%dT%H:%M:%S.") + f"{value.microsecond // 1000:03d}Z"

    # UTC datetime with consistent .000Z milliseconds format
    UtcDatetime = Annotated[datetime, PlainSerializer(_serialize_datetime_ms)]

    def normalize_email(email: str) -> str:
        return email.lower().strip()

    # Normalized email (lowercase, stripped)
    NormalizedEmail = Annotated[EmailStr, AfterValidator(normalize_email)]

    # E.164 phone number format
    Phone = Annotated[
        str,
        StringConstraints(min_length=8, max_length=16, pattern=r"^\+[1-9]\d{6,14}$", strip_whitespace=True),
    ]

    # ISO 639-1 language codes (e.g., "en", "fi")
    LanguageCode = Annotated[str, StringConstraints(min_length=2, max_length=2, pattern=r"^[a-z]{2}$")]

    # ISO 3166-1 alpha-2 country codes (e.g., "US", "FI")
    CountryCode = Annotated[str, StringConstraints(min_length=2, max_length=2, pattern=r"^[A-Z]{2}$")]
    ```
  - Usage in models:
    ```python
    from app.models.types import NormalizedEmail, Phone, UtcDatetime

    class ProfileBase(BaseModel):
        email: NormalizedEmail = Field(..., description="Email (auto-lowercased)")
        phone_number: Phone = Field(..., description="Phone in E.164 format")

    class Profile(BaseModel):
        # ... other fields
        created_at: UtcDatetime = Field(..., description="Creation timestamp", examples=["2025-01-15T10:30:00.000Z"])
        updated_at: UtcDatetime = Field(..., description="Last update timestamp", examples=["2025-01-15T10:30:00.000Z"])
    ```
  - **When NOT to use shared types**: If validation is one-off or needs context-specific error messages, keep inline.

- Domain exceptions (`app/exceptions/`)
  - Define domain exceptions using `fastapi-problem` base classes:
    ```python
    # app/exceptions/base.py
    from fastapi_problem.error import (
        BadRequestProblem,
        ConflictProblem,
        ForbiddenProblem,
        NotFoundProblem,
        ServerProblem,
        UnauthorisedProblem,
        UnprocessableProblem,
    )

    __all__ = [
        "BadRequestProblem",
        "ConflictProblem",
        "ForbiddenProblem",
        "NotFoundProblem",
        "ServerProblem",
        "UnauthorisedProblem",
        "UnprocessableProblem",
    ]
    ```
  - Create resource-specific exceptions:
    ```python
    # app/exceptions/profile.py
    from fastapi_problem.error import ConflictProblem, NotFoundProblem

    class ProfileNotFoundError(NotFoundProblem):
        """Raised when a profile cannot be found."""
        title = "Profile not found"

    class ProfileAlreadyExistsError(ConflictProblem):
        """Raised when attempting to create a duplicate profile."""
        title = "Profile already exists"
    ```
  - Exception handling is centralized via `app/core/exception_handler.py`:
    - Uses `fastapi-problem` singleton `eh` with pre/post hooks
    - Handles validation errors with structured format via `validation_error_handler`
    - Adds `X-Request-ID` to all error responses
    - Adds `$schema` field and `Link` header with `rel="describedBy"` to all error responses via `schema_link_post_hook`
    - Supports CBOR error responses via `CBORProblemPostHook`
    - Strips extras from 5xx errors in production via `StripExtrasPostHook`
  - Register handlers in `main.py`: `add_exception_handler(app, eh)`
  - Import exceptions from the package root:
    ```python
    from app.exceptions import ProfileNotFoundError, ProfileAlreadyExistsError
    ```
  - Domain exceptions are automatically converted to RFC 9457 Problem Details responses.

- Types & structure
  - Ruff ANN rules enforce type annotations. Reuse existing domain models; prefer narrow types over `dict[str, object]`.

- Configuration & secrets
  - Use `pydantic-settings` for config. Never hardcode secrets. Load via env or Secret Manager.
  - Do not log secrets or PII. Redact sensitive fields in logs.

- Error handling & logging
  - Use `app/middleware/logging.py` configuration. Include request context where useful.
  - Wrap critical paths in try/except with actionable messages; avoid silencing exceptions.
  - **Structured logging with `extra={}`**: Always use `extra={}` dict for contextual data instead of `%s` formatting. This ensures proper JSON structured logging for Cloud Logging:
    ```python
    # Correct - structured logging with extra
    logger.info("Profile created", extra={"user_id": uid, "profile_id": uid})
    logger.warning("Invalid input", extra={"field": "email", "value": masked_email})
    logger.exception("Error creating profile", extra={"user_id": uid})

    # Wrong - %s formatting loses structure in JSON logs
    logger.info("Profile created for user %s", uid)
    logger.exception("Error creating profile for user %s", uid)
    ```
  - **Logger levels**:
    - `logger.exception(...)` for unexpected failures inside `except` blocks.
    - `logger.warning(...)` for expected validation failures or rejected actions.
    - `logger.info(...)` for meaningful business events (not per-request chatter).
    - `logger.debug(...)` for local diagnostics (no PII).
  - Use `logger.error(...)` only for high-severity conditions not raised as exceptions; inside `except` always prefer `logger.exception(...)`.
  - **Exception logging**: Use `logger.exception()` inside exception handlers. It automatically captures exception type, message, and full stack trace. Never manually stringify exceptions:
    ```python
    # Correct - captures full stack trace
    except Exception:
        logger.exception("Failed to create profile", extra={"user_id": user_id})
        raise HTTPException(status_code=500, detail="Unable to create profile") from None

    # Wrong - loses stack trace and exception type
    except Exception as e:
        logger.error("Failed to create profile", extra={"error": str(e)})
    ```
  - **Exception binding (`as e`)**: Use `except Exception:` (no binding) when you only need to log and re-raise. Use `except Exception as e:` only when you need to access the exception object (e.g., check attributes or chain with `raise ... from e`).
  - **Audit logging**: Use `log_audit_event()` from `app.middleware` for security-relevant operations (create, update, delete). This creates structured audit logs for Cloud Logging:
    ```python
    from app.middleware import log_audit_event

    # In service layer after successful operation
    log_audit_event("create", user_id, "profile", user_id, "success")
    log_audit_event("delete", user_id, "profile", resource_id, "success", details={"reason": "user_request"})
    ```
  - The `app.middleware` package exports: `BodySizeLimitMiddleware`, `CloudRunJSONFormatter`, `RequestContextLogMiddleware`, `SecurityHeadersMiddleware`, `get_logger`, `log_audit_event`, and `setup_logging`.

- Testing & testability
  - **NEVER add test-related code to production code.** No `if testing:` branches, no test flags, no mock injection points.
  - If code is not unit testable, refactor it. Use dependency injection, extract interfaces, or restructure — do not pollute production code with test scaffolding.
  - Tests belong in `tests/`; production code must remain test-agnostic.
  - Example of what NOT to do:
    ```python
    # Wrong - test flag in production code
    def get_client(testing: bool = False):
        if testing:
            return MockClient()
        return RealClient()

    # Correct - use dependency injection
    def get_client() -> Client:
        return RealClient()
    
    # In tests: override via FastAPI dependency or fixture
    ```

- Firebase/Google Cloud
  - Initialize Firebase/clients via `app/core/firebase.py` and dependencies. Inject via FastAPI dependencies.
  - Use `get_async_firestore_client()` for async Firestore operations; use `@firestore.async_transactional` for atomic updates.
  - Call `close_async_firestore_client()` on app shutdown (via lifespan manager).
  - Avoid direct network access in unit tests; use mocks/stubs.

- Style & linting
  - Ruff enforces all code style. Run `just lint` before committing.
  - Avoid `# noqa` unless truly necessary; include justification if used.
  - Keep unused parameters named (e.g., `request: Request` in handlers) for API clarity.

---

## Testing Guidelines

1) Coverage & scope
   - Write tests for all new features and bug fixes.
   - Aim for 90%+ overall coverage, and 100% on critical business logic paths.
   - Include edge cases, error handling, and auth/permission scenarios.

2) Structure & style
   - Unit tests: `tests/unit/**` (mirror `app/` folder structure)
   - Integration tests: `tests/integration/**` (mirror `app/api/` structure)
   - E2E tests: `tests/e2e/**` (local only, requires Firebase emulators)
   - Use `pytest` with `pytest-asyncio` for async tests (`asyncio_mode = "auto"` in pyproject.toml; no decorator needed).
   - Unit tests must not use real network/Firestore; mock Firebase Admin/clients.
   - Integration tests use the FastAPI app test client; keep external calls mocked.
   - E2E tests run against real Firebase emulators; not included in CI.

3) Running
   - `just test` — Unit + integration tests (CI-compatible)
   - `just test-unit` — Unit tests only
   - `just test-integration` — Integration tests only
   - `just test-e2e` — E2E tests (requires `just emulators` running)
   - `just test-all` — All tests including E2E
   - `just cov` — Coverage report (html/json)

---

## API Documentation

- FastAPI generates OpenAPI automatically. Keep `response_model`, `responses`, `tags`, and docstrings accurate.
- Provide request/response examples where useful using FastAPI `examples` in model/route definitions.
- If introducing a shared error format, define a canonical error model (e.g., `ProblemResponse`) and reuse it across endpoints.
- **Never use `content` or `content_from_model()`** in `responses` declarations. FastAPI auto-generates schema from the `model` parameter:
  ```python
  # Correct - include model for all status codes (2XX and errors)
  responses={
      200: {"model": ItemResponse, "description": "Item retrieved successfully"},
      404: {"model": ProblemResponse, "description": "Not found"},
  }

  # Wrong - do not use content or content_from_model
  responses={
      404: {"model": ProblemResponse, "description": "Not found", "content": content_from_model(...)},
  }
  ```

### Return Type Annotations as Response Model

FastAPI uses return type annotations as implicit `response_model`. You can omit the explicit `response_model=` parameter when the return type annotation is a Pydantic model:
```python
# Preferred - return type serves as response_model
@router.get("")
async def get_profile(current_user: CurrentUser) -> ProfileResponse:
    ...

# Also valid - explicit response_model (useful for response_model_exclude_unset)
@router.patch("", response_model=ProfileResponse, response_model_exclude_unset=True)
async def update_profile(...) -> ProfileResponse:
    ...
```

Use explicit `response_model=` when you need additional options like `response_model_exclude_unset=True` for partial update endpoints.

### Operation ID Naming Convention

Use stable `operation_id` values with the pattern `<area>_<resource>_<action>` for consistent client SDK generation:
```python
@router.post("", operation_id="profile_create", ...)
@router.get("", operation_id="profile_get", ...)
@router.patch("", operation_id="profile_update", ...)
@router.delete("", operation_id="profile_delete", ...)
```

This ensures generated client methods have predictable names (e.g., `client.profile_create()`).

### Router-Level Configuration

Configure common settings at the router level to reduce repetition:
```python
from fastapi import APIRouter
from app.models.error import ProblemResponse

router = APIRouter(
    prefix="/profile",
    tags=["Profile"],
    responses={
        401: {"model": ProblemResponse, "description": "Unauthorized"},
        500: {"model": ProblemResponse, "description": "Server error"},
    },
)
```

Route-specific responses merge with router-level responses, so you only need to declare unique status codes per route.

### Route Response Model Verification

All API routes must use Pydantic response models for type safety and OpenAPI documentation.

**Required for every route:**
1. Return type annotation with a Pydantic model class (or explicit `response_model=`)
2. `responses={}` dict with:
   - Success status code (200/201) with `model=` and `description` for clear OpenAPI docs
   - **204 No Content**: Omit `model=` (HTTP spec prohibits body); only `description` is required
   - Error status codes (400, 401, 403, 404, 409, 500) with `model=ProblemResponse`

**Example with 2XX success response:**
```python
@router.post(
    "",
    status_code=status.HTTP_201_CREATED,
    operation_id="profile_create",
    responses={
        201: {"model": ProfileResponse, "description": "Profile created successfully"},
        409: {"model": ProblemResponse, "description": "Profile already exists"},
    },
)
async def create_profile(...) -> ProfileResponse:
    ...
```

**For partial updates** (PATCH endpoints), use `response_model_exclude_unset=True` to omit fields not explicitly set:
```python
@router.patch(
    "",
    response_model=ProfileResponse,
    response_model_exclude_unset=True,
    operation_id="profile_update",
    responses={...},
)
async def update_profile(...) -> ProfileResponse:
    ...
```

**For DELETE endpoints with 204 No Content:**
```python
@router.delete(
    "",
    status_code=status.HTTP_204_NO_CONTENT,
    operation_id="profile_delete",
    responses={
        204: {"description": "Profile deleted successfully"},  # No model - HTTP spec prohibits body
        404: {"model": ProblemResponse, "description": "Profile not found"},
    },
)
async def delete_profile(...) -> None:
    ...
    return None
```

**Common issues to fix:**
- Missing return type annotation or `response_model` parameter
- Missing `model=` or `description` for 2XX success responses (except 204)
- `responses` dict without `model=ProblemResponse` for error codes
- Returning raw dicts instead of Pydantic models
- Using `dict` or `Any` as return type instead of specific model
- Missing `operation_id` for client SDK stability

---

## Project Structure

- `app/` — FastAPI app:
  - `api/` — API route definitions with versioning:
    - `__init__.py` — Exports `v1_router` (versioned prefix `/v1`) containing `profile`, `hello`, `items` routers
    - `health.py`, `schemas.py` — Unversioned routes at `/health`, `/schemas`
    - `profile.py`, `hello.py`, `items.py` — Business endpoint routers (mounted under `/v1/`)
  - `auth/` — Firebase authentication (`verify_firebase_token`, `FirebaseUser`, `security` HTTPBearer scheme)
  - `core/` — Configuration (`config.py`), Firebase initialization (`firebase.py`), exception handler (`exception_handler.py`), CBOR support (`cbor.py`), validation (`validation.py`), shared constants (`constants.py`)
  - `dependencies.py` — Dependency injection aliases (`CurrentUser`, `ProfileServiceDep`, service providers)
  - `exceptions/` — Domain exceptions using `fastapi-problem` (`base.py` re-exports, resource-specific in `profile.py`, `schema.py`)
  - `middleware/` — ASGI middleware (body limit, logging with W3C traceparent correlation, security headers); exports `log_audit_event`, `setup_logging`, `get_logger`
  - `models/` — Pydantic schemas organized by domain subdirectories:
    - `profile/` — `requests.py` (ProfileCreate, ProfileUpdate), `responses.py` (Profile, PROFILE_COLLECTION)
    - `health/`, `hello/`, `items/` — Similar structure with domain-specific models
    - `types.py` — Shared type aliases (UtcDatetime, NormalizedEmail, Phone, etc.)
    - `error.py` — Error response models (ProblemResponse, ValidationProblemResponse)
  - `pagination/` — Cursor-based pagination utilities (`cursor.py`, `link.py`, `paginator.py`, `params.py`)
  - `services/` — Business logic organized by domain subdirectories:
    - `profile/` — `service.py` containing ProfileService with async Firestore operations
- `tests/` — unit and integration tests
- `functions/` — Firebase Cloud Functions (Python 3.14) codebase (`main.py`, its own `pyproject.toml`)
- `Justfile` — dev/test/build tasks
- `pyproject.toml` — dependencies and tool configs (Ruff, ty, pytest, coverage)

Keep routers focused on I/O and validation; put domain logic in `services/`; keep shared configuration/utilities in `core/`.

### Monorepo Considerations (FastAPI app + Cloud Functions)

When adding features, decide if logic belongs in the FastAPI service (`app/`) or a Cloud Function (`functions/`):

| Scenario | Prefer FastAPI (`app/`) | Prefer Cloud Function (`functions/`) |
| -------- | ----------------------- | ------------------------------------ |
| Multiple cohesive REST endpoints | Yes | No |
| Single lightweight webhook / experimental endpoint | No | Yes |
| Requires custom middleware chain / shared service layer | Yes | No |
| Spiky, low average traffic (cost optimize) | Maybe | Yes |
| Long-lived streaming / websockets | Yes | No |

Cloud Functions specifics:
- Runtime pinned via `firebase.json` (`python314`, region `europe-west4`).
- Global scaling options in `functions/main.py` (memory 128MB; env-param `MIN_INSTANCES` default 0, `MAX_INSTANCES` default 2).
- Dependencies managed via `functions/pyproject.toml`; uses uv by default on Python 3.14+. Keep deps lean to reduce cold starts.
- Add new functions by decorating callables with `@https_fn.on_request()` (or other trigger types) inside `functions/main.py` (or split into modules imported by `main.py`).
- Deployment: `firebase deploy --only functions`.
- Emulator: `firebase emulators:start --only functions` (ports defined in `firebase.json`).
- Vertex / Generative AI support is optional—uncomment and configure client if needed.

Agent guidance:
1. If a change affects shared domain logic used by both environments, refactor into a neutral module under a new `shared/` or reuse `app/services/` only if no Firebase-only dependencies leak in.
2. Avoid importing FastAPI-specific middleware or app objects inside `functions/` code.
3. When editing both layers, create separate commits/patch hunks logically grouped (e.g., "feat(functions): add X" and "feat(api): expose X endpoint").
4. Keep environment variables documented in the top-level README when introducing new cross-environment config.
5. For tests of logic used in functions, write pure unit tests under `tests/unit/` that import the shared module—not the Firebase runtime wrapper—to avoid emulator coupling.

CI note: Currently CI focuses on the FastAPI app; if functions gain complex logic, add a lightweight import test (e.g., ensure `functions/main.py` loads) and possibly a dry-run deployment script.

---

## Useful CLI Commands (via just)

### Test Commands

| Command                 | Purpose                                             |
| ----------------------- | --------------------------------------------------- |
| `just test`             | Run unit + integration tests (CI-compatible)        |
| `just test-unit`        | Run unit tests only                                 |
| `just test-integration` | Run integration tests only                          |
| `just test-e2e`         | Run E2E tests (requires Firebase emulators)         |
| `just test-all`         | Run all tests including E2E                         |
| `just cov`              | Run tests with coverage (html report to `htmlcov/`) |
| `just emulators`        | Start Firebase emulators for E2E tests              |

### Quality Assurance Commands

| Command                 | Purpose                                             |
| ----------------------- | --------------------------------------------------- |
| `just lint`             | Ruff check + format check                           |
| `just fix`              | Ruff check --fix + format (auto-fix issues)         |
| `just typing`           | Type checking via ty                                |
| `just modernize`        | Apply safe modernization via Ruff's pyupgrade rules |
| `just qa`               | Run fix, typing, and test                           |
| `just check`            | Run lint, typing, and test                          |

### Run Commands

| Command                 | Purpose                                             |
| ----------------------- | --------------------------------------------------- |
| `just serve`            | Run dev server on http://127.0.0.1:8080             |
| `just req <path>`       | Send HTTP request to dev server via httpie          |
| `just browser`          | Open dev server in web browser                      |

### Container Commands

| Command                 | Purpose                                             |
| ----------------------- | --------------------------------------------------- |
| `just docker-build`     | Build Docker image (`fastapi-playground:local`)     |
| `just docker-up`        | Start container in detached mode on port 8080       |
| `just docker-down`      | Stop the running container                          |
| `just docker-logs`      | Stream container logs (Ctrl+C to exit)              |

### Lifecycle Commands

| Command                 | Purpose                                             |
| ----------------------- | --------------------------------------------------- |
| `just install`          | Sync dependencies with uv                           |
| `just update`           | Upgrade dependencies with uv                        |
| `just clean`            | Remove caches and temporary files                   |
| `just fresh`            | Clean and reinstall                                 |

### Notes

- Override dev server port via `PORT` env (default 8080).
- Docker workflow: `just docker-build` → `just docker-up` → `just docker-down`.

---

## Pull Requests & Code Review

- PRs must include a clear description, rationale, and link to any related issue.
- Include/update tests and API docs where relevant.
- Use Conventional Commits for messages.
- Keep diffs focused; avoid unrelated refactors in the same PR.

Checklist for PRs
- [ ] Tests added/updated and passing locally (`just check`)
- [ ] Coverage meets target (aim ≥90%)
- [ ] Lint/type checks clean (Ruff/ty)
- [ ] API responses/docs accurate (response models, codes, examples)

---

## Secrets & Environment Variables

- Never commit secrets. Use a local `.env` (gitignored) and Secret Manager in production.
- Access config through settings classes (pydantic-settings); don't read env directly in business logic.
- Don't log secrets or PII; ensure logs redact sensitive fields.
- Typical env vars
  - `ENVIRONMENT`, `DEBUG`
  - `GOOGLE_APPLICATION_CREDENTIALS` (path to service account JSON)
  - `FIREBASE_PROJECT_ID` (also used for trace correlation; `GCP_PROJECT_ID` deprecated)
  - `FIREBASE_PROJECT_NUMBER` (optional, for project number reference)
  - `FIRESTORE_DATABASE` (optional, Firestore database ID; defaults to `(default)`)
  - `MAX_REQUEST_SIZE_BYTES` (default 1,000,000; maximum request body size)
  - `CORS_ORIGINS` (JSON array or comma-separated list of allowed origins)
  - `SECRET_MANAGER_ENABLED` (default true; enable/disable Secret Manager)
---

## CI Required Checks (recommended)

Per change, run and require the following for green status:
- Lint/format: `just lint`
- Typecheck: `just typing`
- Tests: `just test` (or `just cov`) with coverage thresholds enforced
- Optional: container build and a basic smoke test (if Dockerized deployment is in use)

---

## Agent Execution Guardrails

- Reflect on tool results and pick the best next action before proceeding.
- Prefer batching independent read-only steps in parallel; avoid redundant reads.
- Clean up temporary files/scripts before finishing a task.
- Do not invent paths/APIs/commands—verify from repo or tooling.
- For runnable code changes, run minimal tests to validate, report PASS/FAIL succinctly, and iterate up to three targeted fixes if needed.
