# Copilot Instructions

These guidelines define how AI agents and contributors should work in this FastAPI/Python repository. Use GitHub Issues/PRs for tracking, GitHub Actions for CI (if configured), and local tooling via uv and just.

> **Ruff Linter Coverage**: Code quality is enforced via Ruff with comprehensive rules in `pyproject.toml`:
> - **ANN**: Type annotations required (functions, args, returns)
> - **B**: Bugbear patterns (mutable defaults, unused loop vars)
> - **C4/SIM**: Simplification (comprehensions, boolean logic)
> - **FAST**: FastAPI-specific (redundant response_model, unused path params)
> - **G/LOG**: Logging format (no f-strings in log calls, use logger.exception)
> - **I**: Import sorting (automatic via Ruff formatter)
> - **N**: PEP8 naming conventions (classes, functions, variables)
> - **PT**: Pytest style (fixture syntax, assertion patterns)
> - **RET**: Return statement patterns (no implicit returns, no unnecessary else)
> - **S**: Security (bandit rules, no hardcoded secrets)
> - **T20**: No print statements (use logging)
> - **TRY**: Exception handling patterns
> - **UP**: Modern Python syntax (pyupgrade for 3.14+)
>
> Run `just lint` to check and auto-fix. This document focuses only on project-specific conventions.

---

## Comment & Output Restraint

Keep output and code/doc comments minimal and purposeful.

- Do NOT add progress logs, narrative explanations, or meta commentary (e.g., "updating file", "starting patch", "work in progress") to source code, docs, tests, or commit diffs.
- No autogenerated banners or markers like "Generated by".
- Never use emojis in code, comments, documentation, or commit messages.
- Inline comments only when they clarify non-obvious intent, business rules, performance trade-offs, or security rationale. Omit comments that restate the code.
- Remove obsolete/stale comments when changing related code.
- Avoid speculative TODOs; only leave a TODO if it is immediately actionable, clearly scoped, and required. Prefer creating a tracked issue instead.
- Do not insert review-style remarks ("nit:", "consider:") inside committed files.
- Keep examples free of progress chatter—only the example code and essential annotations.

Violations should be removed before a PR is marked ready. Default to silence unless a comment adds enduring value.

---

## Workflow Principles

- Correctness first → Prioritize correctness, then readability/maintainability, then performance.
- Reflect before acting → After tool results, briefly summarize insights, list next options, and pick the best one.
- Parallelize independent steps → Run unrelated reads/checks in parallel to maximize efficiency.
- No leftovers → Remove temporary files/scripts/debug outputs before finishing. Keep `git status` clean aside from intended changes.
- No legacy aliases → Never add backwards-compatibility shims or deprecated aliases. Refactor all usages to the new convention instead.
- Ask when unsure → If requirements are ambiguous, seek clarification rather than guessing.
- Well-supported dependencies → Prefer widely used, well-documented libraries with active maintenance. Ask permission before adding new dependencies.
- Security first → Never exfiltrate secrets; avoid network calls unless explicitly required. Do not log PII or secrets.
- After editing code → Run `just lint` and `just typing` to ensure lint/type compliance.

---

## Tech & Tooling

- Language/runtime: Python 3.14+
- Frameworks/libs: FastAPI, Pydantic v2, Uvicorn, Firebase Admin SDK, Google Cloud (Firestore/Logging/Secret Manager)
- Package/devenv: uv (+ virtualenv in `.venv`), Justfile for tasks
- Lint/format: Ruff (line-length 120; comprehensive rules in pyproject.toml)
- Type checking: ty
- Testing: pytest, pytest-asyncio, coverage

Use uv consistently (do not mix with pip/poetry within this repo). Prefer `just` shortcuts where available.

---

## Coding Guidelines

- FastAPI style
  - Use `async def` for I/O-bound endpoints and services.
  - Validate inputs/outputs with Pydantic models; set `response_model` and explicit status codes.
  - Keep separate request/response models (no leaking internal fields).
  - Raise `HTTPException` with clear messages; add contextual logging on failures.
  - Keep routers thin; put business logic in `services/` and shared logic in `core/`.
  - **Use lifespan context manager** for app startup/shutdown. Initialize Firebase and logging on startup; close async clients on shutdown:
    ```python
    from contextlib import asynccontextmanager
    from collections.abc import AsyncGenerator

    @asynccontextmanager
    async def lifespan(app: FastAPI) -> AsyncGenerator[None]:
        """
        Application lifespan manager.
        """
        # Startup
        setup_logging()
        initialize_firebase()
        yield
        # Shutdown
        await close_async_firestore_client()

    app = FastAPI(lifespan=lifespan, ...)
    ```
  - **Middleware order matters**: Last added = outermost (first to run on request). Order in `main.py`:
    1. CORS (innermost) - handles preflight
    2. BodySizeLimitMiddleware - reject oversized requests early
    3. SecurityHeadersMiddleware - add security headers to responses
    4. RequestContextLogMiddleware (outermost) - capture full request lifecycle
  - **Always add meaningful docstrings to endpoint functions.** Describe what the endpoint does, key behaviors, and notable error conditions. The docstring complements the decorator's `summary`/`description` by documenting implementation details for developers:
    ```python
    async def create_profile(...) -> ProfileResponse:
        """
        Create a new profile for the authenticated user.

        Stores the profile data in Firestore under the user's UID.
        Returns 409 Conflict if a profile already exists.
        """
    ```
  - **Prefer `Literal` types over regex patterns** for query parameters with fixed allowed values. `Literal` provides better OpenAPI documentation (enum values in Swagger UI), type checker support, and clearer validation errors:
    ```python
    # Preferred - use Literal for fixed value sets
    from typing import Literal
    sort_order: Annotated[Literal["asc", "desc"] | None, Query(description="Sort order")] = None

    # Avoid - regex pattern for fixed value sets
    sort_order: Annotated[str | None, Query(pattern="^(asc|desc)$")] = None
    ```
  - **Use dependency type aliases** for cleaner router signatures. Define in `app/dependencies.py`:
    ```python
    from typing import Annotated
    from fastapi import Depends
    from app.auth.firebase import FirebaseUser, verify_firebase_token
    from app.services.profile import ProfileService

    # Auth dependency - use in router parameters
    CurrentUser = Annotated[FirebaseUser, Depends(verify_firebase_token)]

    # Service dependency - inject via DI
    def get_profile_service() -> ProfileService:
        """
        Dependency provider for ProfileService.
        """
        return ProfileService()

    ProfileServiceDep = Annotated[ProfileService, Depends(get_profile_service)]
    ```
    Usage in routers:
    ```python
    from app.dependencies import CurrentUser, ProfileServiceDep

    async def create_profile(
        profile_data: ProfileCreate,
        current_user: CurrentUser,
        service: ProfileServiceDep,
    ) -> ProfileResponse:
    ```

- Pydantic schemas (`app/models/`)
  - Always use `model_config = {...}` or `model_config = ConfigDict(...)` at class level. Never use the deprecated `class Config:` inner class.
  - Use `extra="forbid"` for request models to reject unknown fields.
  - Response models typically omit `extra="forbid"` unless strict output is required.
  - **Response models should NOT inherit from request base models** that have `extra="forbid"`. Define full entity models separately to avoid rejecting extra fields in responses:
    ```python
    # Request models with extra="forbid"
    class ProfileBase(BaseModel):
        firstname: str = Field(...)
        # ... other fields
        model_config = ConfigDict(extra="forbid")

    class ProfileCreate(ProfileBase):
        pass

    # Response model - does NOT inherit from ProfileBase
    class Profile(BaseModel):
        """
        Complete profile model with metadata.

        Note: Does not inherit from ProfileBase to avoid extra="forbid" which is
        inappropriate for response models.
        """
        id: str = Field(...)
        firstname: str = Field(...)
        # ... all fields defined explicitly
        created_at: datetime = Field(...)
        updated_at: datetime = Field(...)
    ```
  - Use `from_attributes=True` for models that need to be constructed from ORM-like objects or dataclasses.
  - Use Pydantic v2 `.model_dump()` for serialization instead of deprecated `.dict()`. Use `exclude_unset=True` for partial updates.
  - Add docstrings to models describing their purpose.
  - Use `Field(...)` with `description` for OpenAPI documentation.
  - **Firestore collection constants**: Define collection names as module-level constants in the relevant model file:
    ```python
    # app/models/profile.py
    PROFILE_COLLECTION = "profiles"
    ```
    Import and use in services to ensure consistency.
  - **Field-level examples (required)**: Every field MUST have `Field(examples=[...])` for OpenAPI documentation. This provides per-field examples in Swagger/ReDoc:
    ```python
    from pydantic import BaseModel, EmailStr, Field

    class ProfileCreate(BaseModel):
        """
        Request schema for creating a profile.
        """

        firstname: str = Field(..., min_length=1, max_length=100, description="First name", examples=["John"])
        lastname: str = Field(..., min_length=1, max_length=100, description="Last name", examples=["Doe"])
        email: EmailStr = Field(..., description="Email address", examples=["user@example.com"])
        phone_number: str = Field(..., description="Phone in E.164 format", examples=["+358401234567"])
        marketing: bool = Field(default=False, description="Marketing opt-in", examples=[False])
    ```
  - **Do not use `json_schema_extra`**: Model-level `json_schema_extra={"examples": [...]}` is deprecated. Always use field-level `examples=[...]` instead.
  - **Example format by field type**:
    | Field Type | Example Format |
    |------------|----------------|
    | `str` | `examples=["value"]` |
    | `int` | `examples=[123]` |
    | `float` | `examples=[19.99]` |
    | `bool` | `examples=[True]` |
    | `datetime` | `examples=["2025-01-15T10:30:00Z"]` (use ISO 8601 string for JSON Schema) |
    | `list[str]` | `examples=[["item1", "item2"]]` |
    | `EmailStr` | `examples=["user@example.com"]` |
    | `T | None` | Provide example for `T`; omit `None` |
    | Nested models | Omit examples (schema auto-documents) |

- Schema naming conventions
  - **Never reuse a response model as a request body.** Keep request and response models strictly separate.
  - Use consistent naming to distinguish request vs response models:
    | Purpose | Naming Pattern | Example |
    |---------|----------------|---------|
    | Base class (internal) | `{Resource}Base` | `ProfileBase` |
    | Create request | `{Resource}Create` | `ProfileCreate` |
    | Update request | `{Resource}Update` | `ProfileUpdate` |
    | Standard response | `{Resource}Response` | `ProfileResponse` |
    | Full entity (internal) | `{Resource}` | `Profile` |
  - Avoid ambiguous names; always indicate request or response purpose.

- Shared type aliases (`app/models/types.py`)
  - Use predefined type aliases for common constrained strings instead of inline constraints. Create `app/models/types.py` for reusable types:
    ```python
    # app/models/types.py
    from typing import Annotated
    from pydantic import AfterValidator, EmailStr, StringConstraints

    def normalize_email(email: str) -> str:
        return email.lower().strip()

    # Normalized email (lowercase, stripped)
    NormalizedEmail = Annotated[EmailStr, AfterValidator(normalize_email)]

    # E.164 phone number format
    Phone = Annotated[
        str,
        StringConstraints(min_length=8, max_length=16, pattern=r"^\+[1-9]\d{6,14}$", strip_whitespace=True),
    ]

    # ISO 639-1 language codes (e.g., "en", "fi")
    LanguageCode = Annotated[str, StringConstraints(min_length=2, max_length=2, pattern=r"^[a-z]{2}$")]

    # ISO 3166-1 alpha-2 country codes (e.g., "US", "FI")
    CountryCode = Annotated[str, StringConstraints(min_length=2, max_length=2, pattern=r"^[A-Z]{2}$")]
    ```
  - Usage in models:
    ```python
    from app.models.types import NormalizedEmail, Phone

    class ProfileBase(BaseModel):
        email: NormalizedEmail = Field(..., description="Email (auto-lowercased)")
        phone_number: Phone = Field(..., description="Phone in E.164 format")
    ```
  - **When NOT to use shared types**: If validation is one-off or needs context-specific error messages, keep inline.

- Domain exceptions (`app/exceptions/`)
  - Define domain exceptions with HTTP semantics in `app/exceptions/`. Exceptions carry `status_code`, `detail`, and optional `headers` for automatic HTTP response conversion:
    ```python
    # app/exceptions/base.py
    class DomainError(Exception):
        """
        Base for all domain exceptions with HTTP semantics.

        Supports optional headers for cases like rate limiting (Retry-After).
        """

        status_code: int = 500
        detail: str = "Internal error"
        headers: dict[str, str] | None = None

        def __init__(self, detail: str | None = None, headers: dict[str, str] | None = None) -> None:
            self.detail = detail or self.__class__.detail
            self.headers = headers
            super().__init__(self.detail)

    class NotFoundError(DomainError):
        """
        Base for resource not found errors.
        """

        status_code = 404
        detail = "Resource not found"

    class ConflictError(DomainError):
        """
        Base for resource conflict errors.
        """

        status_code = 409
        detail = "Resource conflict"
    ```
  - Create resource-specific exceptions:
    ```python
    # app/exceptions/profile.py
    from app.exceptions.base import ConflictError, NotFoundError

    class ProfileNotFoundError(NotFoundError):
        """
        Raised when a profile cannot be found.
        """

        detail = "Profile not found"

    class ProfileAlreadyExistsError(ConflictError):
        """
        Raised when attempting to create a duplicate profile.
        """

        detail = "Profile already exists"
    ```
  - Exception handlers are modular under `app/core/handlers/`:
    - `domain.py` - Handles `DomainError` subclasses, returns JSON with `status_code`, `detail`, and optional `headers`
    - `http.py` - Handles `HTTPException` with appropriate logging (error for 5xx, warning for 4xx)
    - `validation.py` - Handles `RequestValidationError` for 422 responses
    - `registration.py` - Exports `register_exception_handlers(app)` to wire all handlers
  - Import handlers via the package root: `from app.core.handlers import register_exception_handlers`
  - Register handlers in `main.py` using `register_exception_handlers(app)`.
  - In routers and services, import exceptions from the package root:
    ```python
    # Preferred - import from package root
    from app.exceptions import ProfileNotFoundError, ProfileAlreadyExistsError

    # In submodules, import from base
    from app.exceptions.base import ConflictError, NotFoundError
    ```
  - In routers, catch and re-raise domain exceptions to let the handler convert them. Use `from None` to suppress exception chaining in generic error responses:
    ```python
    except (HTTPException, ProfileNotFoundError):
        raise
    except Exception:
        logger.exception("Error getting profile", extra={"user_id": current_user.uid})
        raise HTTPException(status_code=500, detail="Failed to retrieve profile") from None
    ```

- Types & structure
  - Ruff ANN rules enforce type annotations. Reuse existing domain models; prefer narrow types over `dict[str, object]`.

- Configuration & secrets
  - Use `pydantic-settings` for config. Never hardcode secrets. Load via env or Secret Manager.
  - Do not log secrets or PII. Redact sensitive fields in logs.

- Error handling & logging
  - Use `app/middleware/logging.py` configuration. Include request context where useful.
  - Wrap critical paths in try/except with actionable messages; avoid silencing exceptions.
  - **Structured logging with `extra={}`**: Always use `extra={}` dict for contextual data instead of `%s` formatting. This ensures proper JSON structured logging for Cloud Logging:
    ```python
    # Correct - structured logging with extra
    logger.info("Profile created", extra={"user_id": uid, "profile_id": uid})
    logger.warning("Invalid input", extra={"field": "email", "value": masked_email})
    logger.exception("Error creating profile", extra={"user_id": uid})

    # Wrong - %s formatting loses structure in JSON logs
    logger.info("Profile created for user %s", uid)
    logger.exception("Error creating profile for user %s", uid)
    ```
  - **Logger levels**:
    - `logger.exception(...)` for unexpected failures inside `except` blocks.
    - `logger.warning(...)` for expected validation failures or rejected actions.
    - `logger.info(...)` for meaningful business events (not per-request chatter).
    - `logger.debug(...)` for local diagnostics (no PII).
  - Use `logger.error(...)` only for high-severity conditions not raised as exceptions; inside `except` always prefer `logger.exception(...)`.
  - **Exception logging**: Use `logger.exception()` inside exception handlers. It automatically captures exception type, message, and full stack trace. Never manually stringify exceptions:
    ```python
    # Correct - captures full stack trace
    except Exception:
        logger.exception("Failed to create profile", extra={"user_id": user_id})
        raise HTTPException(status_code=500, detail="Unable to create profile") from None

    # Wrong - loses stack trace and exception type
    except Exception as e:
        logger.error("Failed to create profile", extra={"error": str(e)})
    ```
  - **Exception binding (`as e`)**: Use `except Exception:` (no binding) when you only need to log and re-raise. Use `except Exception as e:` only when you need to access the exception object (e.g., check attributes or chain with `raise ... from e`).
  - **Audit logging**: Use `log_audit_event()` from `app.middleware` for security-relevant operations (create, update, delete). This creates structured audit logs for Cloud Logging:
    ```python
    from app.middleware import log_audit_event

    # In service layer after successful operation
    log_audit_event("create", user_id, "profile", user_id, "success")
    log_audit_event("delete", user_id, "profile", resource_id, "success", details={"reason": "user_request"})
    ```
  - The `app.middleware` package exports: `BodySizeLimitMiddleware`, `CloudRunJSONFormatter`, `RequestContextLogMiddleware`, `SecurityHeadersMiddleware`, `get_logger`, `log_audit_event`, and `setup_logging`.

- Testing & testability
  - **NEVER add test-related code to production code.** No `if testing:` branches, no test flags, no mock injection points.
  - If code is not unit testable, refactor it. Use dependency injection, extract interfaces, or restructure — do not pollute production code with test scaffolding.
  - Tests belong in `tests/`; production code must remain test-agnostic.
  - Example of what NOT to do:
    ```python
    # Wrong - test flag in production code
    def get_client(testing: bool = False):
        if testing:
            return MockClient()
        return RealClient()

    # Correct - use dependency injection
    def get_client() -> Client:
        return RealClient()
    
    # In tests: override via FastAPI dependency or fixture
    ```

- Firebase/Google Cloud
  - Initialize Firebase/clients via `app/core/firebase.py` and dependencies. Inject via FastAPI dependencies.
  - Use `get_async_firestore_client()` for async Firestore operations; use `@firestore.async_transactional` for atomic updates.
  - Call `close_async_firestore_client()` on app shutdown (via lifespan manager).
  - Avoid direct network access in unit tests; use mocks/stubs.

- Style & linting
  - Ruff enforces all code style. Run `just lint` before committing.
  - Avoid `# noqa` unless truly necessary; include justification if used.
  - Keep unused parameters named (e.g., `request: Request` in handlers) for API clarity.

---

## Testing Guidelines

1) Coverage & scope
   - Write tests for all new features and bug fixes.
   - Aim for 90%+ overall coverage, and 100% on critical business logic paths.
   - Include edge cases, error handling, and auth/permission scenarios.

2) Structure & style
   - Unit tests → `tests/unit/**` (mirror `app/` folder structure)
   - Integration tests → `tests/integration/**` (mirror `app/routers/` structure)
   - E2E tests → `tests/e2e/**` (local only, requires Firebase emulators)
   - Use `pytest` with `pytest-asyncio` for async tests (`asyncio_mode = "auto"` in pyproject.toml; no decorator needed).
   - Unit tests must not use real network/Firestore; mock Firebase Admin/clients.
   - Integration tests use the FastAPI app test client; keep external calls mocked.
   - E2E tests run against real Firebase emulators; not included in CI.

3) Running
   - `just test` — Unit + integration tests (CI-compatible)
   - `just test-unit` — Unit tests only
   - `just test-integration` — Integration tests only
   - `just test-e2e` — E2E tests (requires `just emulators` running)
   - `just test-all` — All tests including E2E
   - `just cov` — Coverage report (html/json)

---

## API Documentation

- FastAPI generates OpenAPI automatically. Keep `response_model`, `responses`, `tags`, and docstrings accurate.
- Provide request/response examples where useful using FastAPI `examples` in model/route definitions.
- If introducing a shared error format, define a canonical error model (e.g., `ErrorResponse`) and reuse it across endpoints.
- **Never use `content` or `content_from_model()`** in `responses` declarations. FastAPI auto-generates schema from the `model` parameter:
  ```python
  # Correct - include model for all status codes (2XX and errors)
  responses={
      200: {"model": ItemResponse, "description": "Item retrieved successfully"},
      404: {"model": ErrorResponse, "description": "Not found"},
  }

  # Wrong - do not use content or content_from_model
  responses={
      404: {"model": ErrorResponse, "description": "Not found", "content": content_from_model(...)},
  }
  ```

### Return Type Annotations as Response Model

FastAPI uses return type annotations as implicit `response_model`. You can omit the explicit `response_model=` parameter when the return type annotation is a Pydantic model:
```python
# Preferred - return type serves as response_model
@router.get("/")
async def get_profile(current_user: CurrentUser) -> ProfileResponse:
    ...

# Also valid - explicit response_model (useful for response_model_exclude_unset)
@router.patch("/", response_model=ProfileResponse, response_model_exclude_unset=True)
async def update_profile(...) -> ProfileResponse:
    ...
```

Use explicit `response_model=` when you need additional options like `response_model_exclude_unset=True` for partial update endpoints.

### Operation ID Naming Convention

Use stable `operation_id` values with the pattern `<area>_<resource>_<action>` for consistent client SDK generation:
```python
@router.post("/", operation_id="profile_create", ...)
@router.get("/", operation_id="profile_get", ...)
@router.patch("/", operation_id="profile_update", ...)
@router.delete("/", operation_id="profile_delete", ...)
```

This ensures generated client methods have predictable names (e.g., `client.profile_create()`).

### Router-Level Configuration

Configure common settings at the router level to reduce repetition:
```python
from fastapi import APIRouter
from app.models.error import ErrorResponse

router = APIRouter(
    prefix="/profile",
    tags=["Profile"],
    responses={
        401: {"model": ErrorResponse, "description": "Unauthorized"},
        500: {"model": ErrorResponse, "description": "Server error"},
    },
)
```

Route-specific responses merge with router-level responses, so you only need to declare unique status codes per route.

### Route Response Model Verification

All API routes must use Pydantic response models for type safety and OpenAPI documentation.

**Required for every route:**
1. Return type annotation with a Pydantic model class (or explicit `response_model=`)
2. `responses={}` dict with:
   - Success status code (200/201/204) with `model=` and `description` for clear OpenAPI docs
   - Error status codes (400, 401, 403, 404, 409, 500) with `model=ErrorResponse`

**Example with 2XX success response:**
```python
@router.post(
    "/",
    status_code=status.HTTP_201_CREATED,
    operation_id="profile_create",
    responses={
        201: {"model": ProfileResponse, "description": "Profile created successfully"},
        409: {"model": ErrorResponse, "description": "Profile already exists"},
    },
)
async def create_profile(...) -> ProfileResponse:
    ...
```

**For partial updates** (PATCH endpoints), use `response_model_exclude_unset=True` to omit fields not explicitly set:
```python
@router.patch(
    "/",
    response_model=ProfileResponse,
    response_model_exclude_unset=True,
    operation_id="profile_update",
    responses={...},
)
async def update_profile(...) -> ProfileResponse:
    ...
```

**Common issues to fix:**
- Missing return type annotation or `response_model` parameter
- Missing `model=` or `description` for 2XX success responses
- `responses` dict without `model=` for error codes
- Returning raw dicts instead of Pydantic models
- Using `dict` or `Any` as return type instead of specific model
- Missing `operation_id` for client SDK stability

---

## Project Structure

- `app/` — FastAPI app:
  - `auth/` — Firebase authentication (`verify_firebase_token`, `FirebaseUser`, `security` HTTPBearer scheme)
  - `core/` — Configuration (`config.py`), Firebase initialization (`firebase.py`), exception handlers (`handlers/`)
  - `core/handlers/` — Modular exception handlers: `domain.py`, `http.py`, `validation.py`, `registration.py`
  - `dependencies.py` — Dependency injection aliases (`CurrentUser`, `ProfileServiceDep`, service providers)
  - `exceptions/` — Domain exceptions with HTTP semantics (`base.py`: `DomainError`, `NotFoundError`, `ConflictError`; resource-specific in e.g., `profile.py`)
  - `middleware/` — ASGI middleware (body limit, logging with Cloud Trace correlation, security headers); exports `log_audit_event`, `setup_logging`, `get_logger`
  - `models/` — Pydantic schemas (`profile.py`, `error.py`, `health.py`), shared type aliases (`types.py`: `NormalizedEmail`, `Phone`, `LanguageCode`, `CountryCode`)
  - `routers/` — API route definitions (`profile.py`, `health.py`)
  - `services/` — Business logic and async Firestore operations with transactions
- `tests/` — unit and integration tests
- `functions/` — Firebase Cloud Functions (Python 3.14) codebase (`main.py`, its own `pyproject.toml`)
- `Justfile` — dev/test/build tasks
- `pyproject.toml` — dependencies and tool configs (Ruff, ty, pytest, coverage)

Keep routers focused on I/O and validation; put domain logic in `services/`; keep shared configuration/utilities in `core/`.

### Monorepo Considerations (FastAPI app + Cloud Functions)

When adding features, decide if logic belongs in the FastAPI service (`app/`) or a Cloud Function (`functions/`):

| Scenario | Prefer FastAPI (`app/`) | Prefer Cloud Function (`functions/`) |
| -------- | ----------------------- | ------------------------------------ |
| Multiple cohesive REST endpoints | ✅ | ❌ |
| Single lightweight webhook / experimental endpoint | ❌ | ✅ |
| Requires custom middleware chain / shared service layer | ✅ | ❌ |
| Spiky, low average traffic (cost optimize) | ⚠️ | ✅ |
| Long-lived streaming / websockets | ✅ | ❌ |

Cloud Functions specifics:
- Runtime pinned via `firebase.json` (`python314`, region `europe-west4`).
- Global scaling options in `functions/main.py` (memory 128MB; env-param `MIN_INSTANCES` default 0, `MAX_INSTANCES` default 2).
- Dependencies managed via `functions/pyproject.toml`; uses uv by default on Python 3.14+. Keep deps lean to reduce cold starts.
- Add new functions by decorating callables with `@https_fn.on_request()` (or other trigger types) inside `functions/main.py` (or split into modules imported by `main.py`).
- Deployment: `firebase deploy --only functions`.
- Emulator: `firebase emulators:start --only functions` (ports defined in `firebase.json`).
- Vertex / Generative AI support is optional—uncomment and configure client if needed.

Agent guidance:
1. If a change affects shared domain logic used by both environments, refactor into a neutral module under a new `shared/` or reuse `app/services/` only if no Firebase-only dependencies leak in.
2. Avoid importing FastAPI-specific middleware or app objects inside `functions/` code.
3. When editing both layers, create separate commits/patch hunks logically grouped (e.g., "feat(functions): add X" and "feat(api): expose X endpoint").
4. Keep environment variables documented in the top-level README when introducing new cross-environment config.
5. For tests of logic used in functions, write pure unit tests under `tests/unit/` that import the shared module—not the Firebase runtime wrapper—to avoid emulator coupling.

CI note: Currently CI focuses on the FastAPI app; if functions gain complex logic, add a lightweight import test (e.g., ensure `functions/main.py` loads) and possibly a dry-run deployment script.

---

## Useful CLI Commands (via just)

| Command           | Purpose                                               |
| ----------------- | ----------------------------------------------------- |
| `just serve`      | Run dev server on http://127.0.0.1:8080               |
| `just test`       | Run unit + integration tests (CI-compatible)          |
| `just test-unit`  | Run unit tests only                                   |
| `just test-integration` | Run integration tests only                      |
| `just test-e2e`   | Run E2E tests (requires Firebase emulators)           |
| `just test-all`   | Run all tests including E2E                           |
| `just cov`        | Run tests with coverage (html report to `htmlcov/`)   |
| `just lint`       | Ruff check + format                                   |
| `just typing`     | Type checking via ty                                  |
| `just check-all`  | Run lint, test, and typing                            |
| `just modernize`  | Apply safe modernization via Ruff's pyupgrade rules   |
| `just install`    | Sync dependencies with uv                             |
| `just update`     | Upgrade dependencies with uv                          |
| `just clean`      | Remove caches and temporary files                     |
| `just fresh`      | Clean and reinstall                                   |
| `just emulators`  | Start Firebase emulators for E2E tests                |

Notes
- You can override dev server port via `PORT` env (default 8080).
- For ad-hoc HTTP against the dev server: `just req <path> [args...]`.

---

## Pull Requests & Code Review

- PRs must include a clear description, rationale, and link to any related issue.
- Include/update tests and API docs where relevant.
- Use Conventional Commits for messages.
- Keep diffs focused; avoid unrelated refactors in the same PR.

Checklist for PRs
- [ ] Tests added/updated and passing locally (`just check-all`)
- [ ] Coverage meets target (aim ≥90%)
- [ ] Lint/type checks clean (Ruff/ty)
- [ ] API responses/docs accurate (response models, codes, examples)

---

## Secrets & Environment Variables

- Never commit secrets. Use a local `.env` (gitignored) and Secret Manager in production.
- Access config through settings classes (pydantic-settings); don’t read env directly in business logic.
- Don’t log secrets or PII; ensure logs redact sensitive fields.
- Typical env vars
  - `ENVIRONMENT`, `DEBUG`
  - `GOOGLE_APPLICATION_CREDENTIALS` (path to service account JSON)
  - `FIREBASE_PROJECT_ID` (also used for trace correlation; `GCP_PROJECT_ID` deprecated)  - `FIREBASE_PROJECT_NUMBER` (optional, for project number reference)
  - `MAX_REQUEST_SIZE_BYTES` (default 1,000,000; maximum request body size)
  - `CORS_ORIGINS` (JSON array or comma-separated list of allowed origins)
  - `SECRET_MANAGER_ENABLED` (default true; enable/disable Secret Manager)
---

## CI Required Checks (recommended)

Per change, run and require the following for green status:
- Lint/format: `just lint`
- Typecheck: `just typing`
- Tests: `just test` (or `just cov`) with coverage thresholds enforced
- Optional: container build and a basic smoke test (if Dockerized deployment is in use)

---

## Agent Execution Guardrails

- Reflect on tool results and pick the best next action before proceeding.
- Prefer batching independent read-only steps in parallel; avoid redundant reads.
- Clean up temporary files/scripts before finishing a task.
- Do not invent paths/APIs/commands—verify from repo or tooling.
- For runnable code changes, run minimal tests to validate, report PASS/FAIL succinctly, and iterate up to three targeted fixes if needed.
