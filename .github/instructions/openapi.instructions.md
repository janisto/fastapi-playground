---
applyTo: "app/routers/**"
---

Use these rules when adding or updating OpenAPI docs in FastAPI routers. Keep it short, accurate, and consistent with FastAPI docs (response_model, status codes, responses with examples, and security). Prefer Pydantic v2 patterns.

Project facts
- Code lives under `app/` with routers in `app/routers/**` and models in `app/models/**`.
- OpenAPI is auto-generated by FastAPI; enrich it via path operation decorators and Pydantic schema metadata.
- Auth is Bearer (Firebase). Use the security dependency so endpoints are marked secured in OpenAPI.

When changing an API endpoint
- Set `status_code` explicitly (e.g., 201 for creates).
- Provide `summary` and `description` in the decorator; keep them concise and accurate.
- Include `responses={...}` for non-2xx errors (401/403/404/409/500) with a shared error model and minimal examples.
- Provide at least one success example and one error example per operation.
- Ensure `tags` match the router area (router-level tags are preferred; per-route tags only if needed).
- Use stable `operation_id` like `<area>_<resource>_<action>` to keep client SDKs stable.

Security
- Use `HTTPBearer` in a dependency that’s part of the path operation signature. Prefer `Security` over `Depends` when feasible so OpenAPI marks security correctly.
- Repository-specific imports:
	- Security scheme: `from app.auth.firebase import security`
	- Verify function: `from app.auth.firebase import verify_firebase_token` (or `from app.dependencies import get_current_user` wrapper)
	- If you wrap auth (e.g., `_current_user_dependency`), keep `Security(security)` inside that wrapper so OpenAPI still marks Bearer auth.
- Document 401/403 in `responses` with a simple error model and examples.

Schemas and examples (Pydantic v2)
- Define request/response models once under `app/models/**` and import them in routers.
- Add realistic examples using `model_config = {"json_schema_extra": {"examples": [...]}}` on models; or `Field(..., description=..., json_schema_extra={"example": ...})` for field-level examples.
- Keep names consistent with domain models; use `format`/`pattern` where applicable (uuid, date-time, E.164, etc.).

Errors
- Reuse the canonical error model defined in `app/models/error.py`:
	- `from app.models.error import ErrorResponse`
- Reference it in `responses` for 4xx/5xx. Don’t leak secrets/PII in examples.
- FastAPI automatically documents validation errors (422). Only override if you provide a compatible schema/example.

Operation checklist (each endpoint)
- Decorator includes: `summary`, `description`, `operation_id`, `status_code` (if not 200), `response_model`, and `responses` with error models and examples.
- Parameters are typed/validated (path/query/header); path params are required.
- Request body is a Pydantic model (create/update), not a dict.
- Success response has an example; at least one error response has an example.
- Security dependency is present so OpenAPI marks Bearer auth.

Examples

1) Model examples (Pydantic v2)
```python
from pydantic import BaseModel, EmailStr, Field
from datetime import datetime

class ErrorResponse(BaseModel):
	detail: str = Field(..., description="Error message")

class ProfileCreate(BaseModel):
	firstname: str = Field(..., min_length=1, max_length=100)
	lastname: str = Field(..., min_length=1, max_length=100)
	email: EmailStr
	phone_number: str = Field(..., pattern=r"^\+?[1-9]\d{1,14}$")
	marketing: bool = False
	terms: bool

	model_config = {
		"json_schema_extra": {
			"examples": [
				{
					"firstname": "John",
					"lastname": "Doe",
					"email": "john@example.com",
					"phone_number": "+1234567890",
					"marketing": True,
					"terms": True,
				}
			]
		}
	}

class Profile(BaseModel):
	id: str
	firstname: str
	lastname: str
	email: EmailStr
	phone_number: str
	marketing: bool
	terms: bool
	created_at: datetime
	updated_at: datetime

class ProfileResponse(BaseModel):
	success: bool
	message: str
	profile: Profile | None = None
```

2) Router docs on a POST (success + error examples)
```python
from fastapi import APIRouter, status
from fastapi import Security
from fastapi.security import HTTPAuthorizationCredentials
from app.models.error import ErrorResponse
from app.auth.firebase import security

@router.post(
	"/",
	summary="Create user profile",
	description="Create a new profile for the authenticated user.",
	operation_id="profile_create",
	status_code=status.HTTP_201_CREATED,
	response_model=ProfileResponse,
	responses={
		401: {
			"model": ErrorResponse,
			"description": "Unauthorized",
			"content": {"application/json": {"example": {"detail": "Unauthorized"}}},
		},
		403: {
			"model": ErrorResponse,
			"description": "Forbidden",
			"content": {"application/json": {"example": {"detail": "Forbidden"}}},
		},
		409: {
			"model": ErrorResponse,
			"description": "Profile already exists",
			"content": {"application/json": {"example": {"detail": "Profile already exists for this user"}}},
		},
		500: {
			"model": ErrorResponse,
			"description": "Server error",
			"content": {"application/json": {"example": {"detail": "Failed to create profile"}}},
		},
		201: {
			"description": "Profile created",
			"content": {
				"application/json": {
					"example": {
						"success": True,
						"message": "Profile created successfully",
						"profile": {
							"id": "user-123",
							"firstname": "John",
							"lastname": "Doe",
							"email": "john@example.com",
							"phone_number": "+1234567890",
							"marketing": True,
							"terms": True,
							"created_at": "2025-01-01T00:00:00Z",
							"updated_at": "2025-01-01T00:00:00Z",
						},
					}
				}
			},
		},
	},
)
async def create_profile(
	profile_data: ProfileCreate,
	credentials: HTTPAuthorizationCredentials = Security(security),
) -> ProfileResponse:
	...  # implement
```

3) Router docs on GET with not-found example
```python
from app.models.error import ErrorResponse
from app.auth.firebase import security

@router.get(
	"/",
	summary="Get user profile",
	description="Get the profile of the authenticated user.",
	operation_id="profile_get",
	response_model=ProfileResponse,
	responses={
		401: {"model": ErrorResponse, "description": "Unauthorized", "content": {"application/json": {"example": {"detail": "Unauthorized"}}}},
		404: {"model": ErrorResponse, "description": "Profile not found", "content": {"application/json": {"example": {"detail": "Profile not found"}}}},
		500: {"model": ErrorResponse, "description": "Server error", "content": {"application/json": {"example": {"detail": "Failed to retrieve profile"}}}},
		200: {"description": "Profile retrieved", "content": {"application/json": {"example": {"success": True, "message": "Profile retrieved successfully", "profile": {"id": "user-123", "firstname": "John", "lastname": "Doe", "email": "john@example.com", "phone_number": "+1234567890", "marketing": True, "terms": True, "created_at": "2025-01-01T00:00:00Z", "updated_at": "2025-01-01T00:00:00Z"}}}}},
	},
)
async def get_profile(credentials: HTTPAuthorizationCredentials = Security(security)) -> ProfileResponse:
	...
```

Quality gates (before PR)
- Keep `response_model`/`status_code`/`responses` aligned with actual behavior.
- Run: `just lint`, `just typing`, `just test` and ensure examples reflect real shapes.
- If you introduce a shared error model, reuse it across endpoints and update tests accordingly.

Notes
- These conventions align with FastAPI docs on response models, additional responses, examples, and security dependencies.
